---
published: false
date: '2016-08-08 14:26 -0600'
title: ''
author: Shelly Cadora
---
## Configuring Model-Driven Telemetry with YDK

## Model-Driven Configuration for Model-Driven Telemetry

In an [earlier tutorial](https://xrdocs.github.io/telemetry/tutorials/2016-07-25-configuring-model-driven-telemetry-mdt-with-yang/), I wrote about how to configure MDT using the OpenConfig Telemetry YANG model using [ncclient](https://github.com/ncclient/ncclient) and a lot of XML.  An even simpler way to do this is to use [YDK](https://developer.cisco.com/site/ydk/), a developer toolkit that automatically generates APIs directly from YANG models.  The Python classes that are generated by YDK mirror the YANG model hierarchy. So if you know some Python and you understand the YANG model, you can start writing code, no knowledge of NETCONF or XML required.

## The OC Telemetry Model

Let's start by reviewing the struture of the [OpenConfig telemetry model](https://github.com/openconfig/public/blob/master/release/models/telemetry/openconfig-telemetry.yang).

{% capture "output" %}
Script Output:

```
module: openconfig-telemetry
   +--rw telemetry-system
      +--rw sensor-groups
      |  +--rw sensor-group* [sensor-group-id]
      |     +--rw sensor-group-id    -> ../config/sensor-group-id
      |     +--rw config
      |     |  +--rw sensor-group-id?   string
      |     +--ro state
      |     |  +--ro sensor-group-id?   string
      |     +--rw sensor-paths
      |        +--rw sensor-path* [path]
      |           +--rw path      -> ../config/path
      |           +--rw config
      |           |  +--rw path?             string
      |           |  +--rw exclude-filter?   string
      |           +--ro state
      |              +--ro path?             string
      |              +--ro exclude-filter?   string
      +--rw destination-groups
      |  +--rw destination-group* [group-id]
      |     +--rw group-id        -> ../config/group-id
      |     +--rw config
      |     |  +--rw group-id?   string
      |     +--ro state
      |     |  +--ro group-id?   string
      |     +--rw destinations
      |        +--rw destination* [destination-address destination-port]
      |           +--rw destination-address    -> ../config/destination-address
      |           +--rw destination-port       -> ../config/destination-port
      |           +--rw config
      |           |  +--rw destination-address?    inet:ip-address
      |           |  +--rw destination-port?       uint16
      |           |  +--rw destination-protocol?   telemetry-stream-protocol
      |           +--ro state
      |              +--ro destination-address?    inet:ip-address
      |              +--ro destination-port?       uint16
      |              +--ro destination-protocol?   telemetry-stream-protocol
      +--rw subscriptions
         +--rw persistent
         |  +--rw subscription* [subscription-id]
         |     +--rw subscription-id       -> ../config/subscription-id
         |     +--rw config
         |     |  +--rw subscription-id?          uint64
         |     |  +--rw local-source-address?     inet:ip-address
         |     |  +--rw originated-qos-marking?   inet:dscp
         |     +--ro state
         |     |  +--ro subscription-id?          uint64
         |     |  +--ro local-source-address?     inet:ip-address
         |     |  +--ro originated-qos-marking?   inet:dscp
         |     +--rw sensor-profiles
         |     |  +--rw sensor-profile* [sensor-group]
         |     |     +--rw sensor-group    -> ../config/sensor-group
         |     |     +--rw config
         |     |     |  +--rw sensor-group?         -> /telemetry-system/sensor-groups/sensor-group/config/sensor-group-id
         |     |     |  +--rw sample-interval?      uint64
         |     |     |  +--rw heartbeat-interval?   uint64
         |     |     |  +--rw suppress-redundant?   boolean
         |     |     +--ro state
         |     |        +--ro sensor-group?         -> /telemetry-system/sensor-groups/sensor-group/config/sensor-group-id
         |     |        +--ro sample-interval?      uint64
         |     |        +--ro heartbeat-interval?   uint64
         |     |        +--ro suppress-redundant?   boolean
         |     +--rw destination-groups
         |        +--rw destination-group* [group-id]
         |           +--rw group-id    -> ../config/group-id
         |           +--rw config
         |           |  +--rw group-id?   -> ../../../../../../../destination-groups/destination-group/group-id
         |           +--rw state
         |              +--rw group-id?   -> ../../../../../../../destination-groups/destination-group/group-id
         +--rw dynamic
            +--ro subscription* [subscription-id]
               +--ro subscription-id    -> ../state/subscription-id
               +--ro state
               |  +--ro subscription-id?          uint64
               |  +--ro destination-address?      inet:ip-address
               |  +--ro destination-port?         uint16
               |  +--ro destination-protocol?     telemetry-stream-protocol
               |  +--ro sample-interval?          uint64
               |  +--ro heartbeat-interval?       uint64
               |  +--ro suppress-redundant?       boolean
               |  +--ro originated-qos-marking?   inet:dscp
               +--ro sensor-paths
                  +--ro sensor-path* [path]
                     +--ro path     -> ../state/path
                     +--ro state
                        +--ro path?             string
                        +--ro exclude-filter?   string
```  
{% endcapture %}

<div class="notice--warning">
{{ output | markdownify }}
</div>

You can spend a lot of time understanding the intricacies of YANG and all the details, but all we really need to know for now is that the model has three major sections:  

- The **destination-group** tells the router where to send telemetry data and how. Only needed for dial-out configuration.  
- The **sensor-group** identifies a list of YANG models that the router should stream.  
- The **subscription** ties together the destination-group and the sensor-group.  

## Configuring the Router for gRPC Dial-in

YDK leverages ncclient to handle the NETCONF connection:

```python      
from ydk.providers import NetconfServiceProvider
from ydk.services import CRUDService 

HOST = '10.30.111.9'
PORT = 830
USER = 'cisco'
PASS = 'cisco'

xr = NetconfServiceProvider(address=HOST,
                                     port=PORT,
                                     username=USER,
                                     password=PASS,
                                     protocol = 'ssh')
```

And here's what we get:  

{% capture "output" %}
Script Output:

```
<?xml version="1.0"?>
<rpc-reply message-id="urn:uuid:939c718e-81ee-43ec-9733-565aa53fedb2" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
 <data>
  <telemetry-system xmlns="http://openconfig.net/yang/telemetry">
   <sensor-groups>
    <sensor-group>
     <sensor-group-id>SGroup3</sensor-group-id>
     <config>
      <sensor-group-id>SGroup3</sensor-group-id>
     </config>
     <sensor-paths>
      <sensor-path>
       <path>openconfig-interfaces:interfaces%2finterface</path>
       <config>
        <path>openconfig-interfaces:interfaces%2finterface</path>
       </config>
      </sensor-path>
     </sensor-paths>
    </sensor-group>
   </sensor-groups>
   <subscriptions>
    <persistent>
     <subscription>
      <subscription-id>Sub3</subscription-id>
      <config>
       <subscription-id>Sub3</subscription-id>
      </config>
      <sensor-profiles>
       <sensor-profile>
        <sensor-group>SGroup3</sensor-group>
        <config>
         <sensor-group>SGroup3</sensor-group>
         <sample-interval>30000</sample-interval>
        </config>
       </sensor-profile>
      </sensor-profiles>
     </subscription>
    </persistent>
   </subscriptions>
  </telemetry-system>
 </data>
</rpc-reply>


```  
{% endcapture %}

<div class="notice--warning">
{{ output | markdownify }}
</div>

So what does all that mean to the router?  It breaks down into three parts which you'll recall from the YANG model above:  

- The **destination-group** tells the router where to send telemetry data and how.  The absence of a destination-group in the output above alerts us to the fact that this is a dial-in configuration (the collector will initiate the session to the router).
- The **sensor-group** identifies a list of YANG models that the router should stream.  In this case, the router has a sensor-group called "SGroup3" that will send interface statistics data from the OpenConfig Interfaces YANG model.
- The **subscription** ties together the destination-group and the sensor-group.  This router has a subscription name "Sub3" that will send the list of models in SGroup3 at an interval of 30 second (30000 milleseconds).  

If you read the [earlier tutorial](https://xrdocs.github.io/telemetry/tutorials/2016-07-21-configuring-model-driven-telemetry-mdt/) on configuring MDT with CLI, you might recognize this as the same as the gRPC dial-in configuration described there.  If you missed that thrilling installment, the XML above is the YANG equivalent of this CLI:  

{% capture "output" %}
CLI Output:

```
telemetry model-driven
 sensor-group SGroup3
  sensor-path openconfig-interfaces:interfaces/interface
 !
 subscription Sub3
  sensor-group-id SGroup3 sample-interval 30000
 !  
``` 

{% endcapture %}

<div class="notice--info">
{{ output | markdownify }}
</div>

## Edit-Config

So let's say we want to add a second model to SGroup3 (Cisco-IOS-XR-ipv4-arp-oper).  We can do that with the following NETCONF operations:

```python
edit_data = '''
<config>
<telemetry-system xmlns="http://openconfig.net/yang/telemetry">
   <sensor-groups>
    <sensor-group>
     <sensor-group-id>SGroup3</sensor-group-id>
     <sensor-paths>
      <sensor-path>
       <config>
        <path>Cisco-IOS-XR-ipv4-arp-oper:arp%2fnodes%2fnode%2fentries%2fentry</path>
       </config>
      </sensor-path>
     </sensor-paths>
    </sensor-group>
   </sensor-groups>
</config>
'''

xr.edit_config(edit_data, target='candidate', format='xml')
xr.commit()
```

If we do a get-config operation again:  

```python
c = xr.get_config(source='running', filter=('subtree', filter))
print(c)
```

... we'll see that SGroup3 has the new addition.  


{% capture "output" %}
Script Output:

```
<?xml version="1.0"?>
<rpc-reply message-id="urn:uuid:abd0a7ee-5f06-4754-b2a3-dae6e3d797aa" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
 <data>
  <telemetry-system xmlns="http://openconfig.net/yang/telemetry">
   <sensor-groups>
    <sensor-group>
     <sensor-group-id>SGroup3</sensor-group-id>
     <config>
      <sensor-group-id>SGroup3</sensor-group-id>
     </config>
     <sensor-paths>
      <sensor-path>
       <path>openconfig-interfaces:interfaces%2finterface</path>
       <config>
        <path>openconfig-interfaces:interfaces%2finterface</path>
       </config>
      </sensor-path>
      <sensor-path>
       <path>Cisco-IOS-XR-ipv4-arp-oper:arp%2fnodes%2fnode%2fentries%2fentry</path>
       <config>
        <path>Cisco-IOS-XR-ipv4-arp-oper:arp%2fnodes%2fnode%2fentries%2fentry</path>
       </config>
      </sensor-path>
     </sensor-paths>
    </sensor-group>
   </sensor-groups>
   <subscriptions>
    <persistent>
     <subscription>
      <subscription-id>Sub3</subscription-id>
      <config>
       <subscription-id>Sub3</subscription-id>
      </config>
      <sensor-profiles>
       <sensor-profile>
        <sensor-group>SGroup3</sensor-group>
        <config>
         <sensor-group>SGroup3</sensor-group>
         <sample-interval>30000</sample-interval>
        </config>
       </sensor-profile>
      </sensor-profiles>
     </subscription>
    </persistent>
   </subscriptions>
  </telemetry-system>
 </data>
</rpc-reply>

```
{% endcapture %}

<div class="notice--warning">
{{ output | markdownify }}
</div>

And if you need some CLI to reassure yourself that it worked, here it is:

{% capture "output" %}
CLI Output:

```
RP/0/RP0/CPU0:SunC#show run telemetry model-driven
Mon Aug  8 20:09:57.149 UTC
telemetry model-driven
 sensor-group SGroup3
  sensor-path openconfig-interfaces:interfaces/interface
  sensor-path Cisco-IOS-XR-ipv4-arp-oper:arp/nodes/node/entries/entry
 !
 subscription Sub3
  sensor-group-id SGroup3 sample-interval 30000
 !
!
```
{% endcapture %}

<div class="notice--info">
{{ output | markdownify }}
</div>

## Conclusion
Armed with the examples in this blog and a understanding of the telemetry YANG model, you should now be able to use YANG configuration models to configure the router to stream YANG models with the operational data you want.  How's that for model-driven programmability?

