---
published: false
date: '2016-08-08 17:52 -0600'
title: Configuring Model-Driven Telemetry with YDK
author: Shelly Cadora
---
## Configuring Model-Driven Telemetry with YDK

## Model-Driven Configuration for Model-Driven Telemetry

In an [earlier tutorial](https://xrdocs.github.io/telemetry/tutorials/2016-07-25-configuring-model-driven-telemetry-mdt-with-yang/), I wrote about how to configure MDT using the OpenConfig Telemetry YANG model using [ncclient](https://github.com/ncclient/ncclient) and a lot of XML.  An even simpler way to do this is to use [YDK](https://developer.cisco.com/site/ydk/), a developer toolkit that automatically generates APIs directly from YANG models.  The Python classes that are generated by YDK mirror the YANG model hierarchy. So if you know some Python and you understand the YANG model, you can start writing code, no knowledge of NETCONF or XML required. 

In this blog, I'll explain how to configure Telemetry for gRPC dialin using YDK and the OpenConfig Telemetry YANG model.

## Connect to the router

YDK leverages ncclient to handle the NETCONF connection:

```python      
from ydk.providers import NetconfServiceProvider
from ydk.services import CRUDService 

HOST = '10.30.111.9'
PORT = 830
USER = 'cisco'
PASS = 'cisco'

xr = NetconfServiceProvider(address=HOST,
                                     port=PORT,
                                     username=USER,
                                     password=PASS,
                                     protocol = 'ssh')
```

With that, we are now connected to the router:

{% capture "output" %}
CLI Output:

```
RP/0/RP0/CPU0:SunC#show netconf-yang clients
Mon Aug  8 23:01:48.210 UTC
Netconf clients
client session ID|     NC version|    client connect time|        last OP time|        last OP type|    <lock>|
       1386485520|            1.1|         0d  0h  0m  5s|                    |                    |        No|
RP/0/RP0/CPU0:SunC#
``` 

{% endcapture %}

<div class="notice--info">
{{ output | markdownify }}
</div>


## Define the sensor group

We'll start by defining the sensor-group.  Here's the first bit of YDK for that:

```python
import ydk.models.openconfig.openconfig_telemetry as oc_telemetry 

sgroup = oc_telemetry.TelemetrySystem.SensorGroups.SensorGroup()
sgroup.sensor_group_id="SGroup4"
sgroup.config.sensor_group_id="SGroup4"
```

So how did I come up with that?  Look back at the first part of the OC Telemetry YANG model:

{% capture "output" %}
Script Output:

```
module: openconfig-telemetry
   +--rw telemetry-system
      +--rw sensor-groups
      |  +--rw sensor-group* [sensor-group-id]
      |     +--rw sensor-group-id    -> ../config/sensor-group-id
      |     +--rw config
      |     |  +--rw sensor-group-id?   string
   
```  
{% endcapture %}

<div class="notice--warning">
{{ output | markdownify }}
</div>

Start from the top and walk down from telemetry-system to sensor-groups to sensor-group.  Replace the dashes and lowercase syntax with CamelCase syntax and you get that first object: TelemetrySystem.SensorGroups.SensorGroup().  Down to the next level, we have the leaf "sensor-group-id."  YDK converts this to an object variable by replacing the hyphens with underscores.  The sensor-group-id list key is actually a leaf-ref to config/sensor-group-id, both of which are required (hence the two lines that seem redundant but are actually required for syntactic validation).

Going down a little farther in the YANG model with some help from some pyang options, we see that the sensor-group contains a list of sensor-paths.

{% capture "output" %}
Script Output:

```
$ pyang -f tree openconfig-telemetry.yang --tree-path=telemetry-system/sensor-groups/sensor-group/sensor-paths/sensor-path/config
module: openconfig-telemetry
   +--rw telemetry-system
      +--rw sensor-groups
         +--rw sensor-group* [sensor-group-id]
            +--rw sensor-paths
               +--rw sensor-path* [path]
                  +--rw config
                     +--rw path?             string
$
```  
{% endcapture %}

<div class="notice--warning">
{{ output | markdownify }}
</div>

This is how that maps to YDK code:

```python
sgroup.sensor_paths = sgroup.SensorPaths()
new_sensorpath = sgroup.SensorPaths.SensorPath()
new_sensorpath.path = 'Cisco-IOS-XR-infra-statsd-oper:infra-statistics%2finterfaces%2finterface%2flatest%2fgeneric-counters'
new_sensorpath.config.path = 'Cisco-IOS-XR-infra-statsd-oper:infra-statistics%2finterfaces%2finterface%2flatest%2fgeneric-counters'
sgroup.sensor_paths.sensor_path.append(new_sensorpath)
```

So again, following the YANG model, we define the top-level SensorPaths object, then a SensorPath with an object variable "path" that actually defines the path.

## Apply the SensorGroup object to the router

Once you've populated the object, it's trivial to apply it to the router using the create method on the CRUDService object from YDK:

```python
from ydk.services import CRUDService

rpc_service = CRUDService()
rpc_service.create(xr, sgroup)
```

## Instantiate a Subscription Object and Apply It

The Subscription is the final piece of the config.  Again, refer to the YANG model to understand the Python class that you should use.  I'll use pyang with the tree-path option to make it clearer:

{% capture "output" %}
Script Output:

```
$pyang -f tree --tree-path telemetry-system/subscriptions/persistent/subscription/sensor-profiles/sensor-profile openconfig-telemetry.yang

module: openconfig-telemetry
   +--rw telemetry-system
      +--rw subscriptions
         +--rw persistent
            +--rw subscription* [subscription-id]
               +--rw sensor-profiles
                  +--rw sensor-profile* [sensor-group]
                     +--rw sensor-group    -> ../config/sensor-group
                     +--rw config
                     |  +--rw sensor-group?         -> /telemetry-system/sensor-groups/sensor-group/config/sensor-group-id
                     |  +--rw sample-interval?      uint64
                     |  +--rw heartbeat-interval?   uint64
                     |  +--rw suppress-redundant?   boolean
                     +--ro state
                        +--ro sensor-group?         -> /telemetry-system/sensor-groups/sensor-group/config/sensor-group-id
                        +--ro sample-interval?      uint64
                        +--ro heartbeat-interval?   uint64
                        +--ro suppress-redundant?   boolean
                     
```  
{% endcapture %}

<div class="notice--warning">
{{ output | markdownify }}
</div>

This is how that ends up in YDK code:

```python
sub = oc_telemetry.TelemetrySystem.Subscriptions.Persistent.Subscription()
sub.subscription_id = 4
sub.config.subscription_id = 4

sub.sensor_profiles = sub.SensorProfiles()

new_sgroup = sub.SensorProfiles.SensorProfile()
new_sgroup.sensor_group = 'SGroup4'
new_sgroup.config.sensor_group = 'SGroup4'
new_sgroup.config.sample_interval = 30000

sub.sensor_profiles.sensor_profile.append(new_sgroup)

rpc_service.create(xr, sub)
```

## Conclusion
Armed with the examples in this blog and a understanding of the telemetry YANG model, you should now be able to use YANG configuration models to configure the router to stream YANG models with the operational data you want.  How's that for model-driven programmability?


